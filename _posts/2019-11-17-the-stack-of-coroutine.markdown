## 关于协程栈的一些思考

**此文适合对协程有一定了解，使用过协程的人阅读**
协程的运行需要栈，当任务切换时用来保存栈上等数据，再次上调度时，协程可以以之前状态继续运行。对栈的处理很关键，影响到整个协程库的性能。对于协程栈的类型，个人分成了两类，动态栈和静态栈，共享栈和非共享栈。

#### 动态栈和静态栈区别
动态栈即可以根据按需扩大容量，而静态栈容量一旦固定便不改变。
#### 共享栈和非共享栈
非共享栈指该线程上的每一个协程都有一个独立的栈(stackful)，共享栈指该线程上的所有协程共享一个栈(stackless)，因为协程不是真正的并发，同一时刻只有一个在运行，因此该做法是可能实现的。

### 下面说一下具体的实现

#### 静态栈
每个协程创建时，分配固定大小的栈，之后不再改变，这是最简单的做法，缺点也很明显，栈的大小很难判断，如果栈的空间较大，那么可能有很多协程并没有使用到该空间，内存浪费严重，如果栈空间较小，那么可能很容易就导致栈溢出。

#### 动态栈
这是go程所采用的方法，栈的大小动态增长，等到栈空间不够时，释放掉原来的空间，重新分配更大的空间(例如可以是之前的两倍)，把之前的内容复制到新栈，栈顶指针指向新栈。事情就这么完成了吗，并没有这么容易。旧栈已经被释放了，所有的引用都已经失效，因此所有指向旧栈的指针都得更新，使其指向新栈，这是一个很麻烦的问题，在c/c++这种没有GC的语言是很难办到的，你无法确定栈帧上哪些是指针，哪些是数据，如果无法保证正确性，那么一切都没有意义。go语言因为本身有GC，因此可以识别出栈上的对象。因此如果写c/c++的协程库，这个方法是不可行的。关于GC对栈上对象的识别，不在讨论范围内(这里推荐一本书《垃圾回收的算法与实现》)。

#### 共享栈
这是libco采用的方法，每次任务切换时，根据当前任务使用的栈大小，申请新的空间，将当前任务共享栈上的数据保存下来，同时，将新任务的栈copy到共享栈，共享栈只有一个，因此肯定是直接申请一块大的空间，栈溢出的问题基本可以解决。共享栈大大减少了内存消耗，对于一次运行完成的任务，不会有额外的空间开销，内存都是按需申请，不会有浪费的问题出现，这样看来共享栈还是有很大的优点。但是！共享栈使用不当是会出现bug的，考虑协程A创建了子协程B，子协程B引用了父协程栈上的对象c，由于栈是共享的，同一时刻只能供一个协程使用，子协程B对c的引用现在可能不在栈上了，被B的数据所覆盖。另外一个问题是当任务占用的栈空间都比较大，共享栈的优点便不再明显了，如果协程频繁地换入换出，每次都要经历两次copy，这样带来的cpu消耗会很大，反而降低了性能。

#### 虚拟内存机制
上面说了这么多，其实还有一个关键的问题没有考虑到，那就是操作系统的虚拟内存。用户态申请内存时，永远是延迟的，系统只是分配一块虚拟地址空间给你，只要你不用到这个空间那么物理内存永远不会被分配，在64位机上，虚拟内存空间是很大，个人觉得基本不用去担心地址空间不够用的问题，不过系统具体给堆预留了多大的地址空间本人也不是很清楚，因此简单粗暴地给每个协程分配一块大空间(比如说1M)也是一个很好的解决方案，libgo就是这么处理的。不过即便是虚拟地址空间，感觉也是一种浪费呢，另外该方案在32位机上是行不通的，32位机的地址空间十分有限，完全经不起这么浪费。

#### 分段栈(split stack)
分段栈是另外一种很特殊的处理方式，需要编译器的支持。1.4版本之前的go用的便是分段栈。在函数调用前，检查栈空间是否够用，如果空间不够，遍申请新的空间，将函数的挪到新空间上执行，执行完再返回原来的栈。这里只是说了个大概，具体情况本人水平有限，目前还不是很清楚。在gcc中，开启-fsplit-stack可实现。后来因为效率原因go改用了动态栈方式实现。

## end
说了这么多，没有一个方案是可以完美解决问题的，每一个都有各自的特点。写c/c++协程库时，需要慎重选择栈处理方式。

### 一些参考资料
[风云的coroutine](https://github.com/cloudwu/coroutine) 只有200行代码左右，使用共享栈的例子，入门级。
[gcc split stack](https://gcc.gnu.org/wiki/SplitStacks)

